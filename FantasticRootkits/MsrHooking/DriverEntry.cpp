#pragma once
#include <ntddk.h>
#include <wdm.h>
#include <intrin.h>

#ifdef _X64
#define IA32_LSTAR 0xc0000082
#else
#define IA32_SYSENTER_EIP 0x176
#endif

#define IOCTL_MYDRIVER_HOOK_MSR CTL_CODE(FILE_DEVICE_UNKNOWN, 0x810, METHOD_BUFFERED, FILE_ANY_ACCESS)

PDEVICE_OBJECT ptrDeviceObject = NULL;

/* Global variable for storing old MSR address. */
UINT_PTR oldMSRAddress = NULL;

NTSTATUS DriverPassthrough(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Irp->IoStatus.Status;
}

#ifdef _WIN32
UINT_PTR ReadMSR()
{
    UINT_PTR msr = 0;
    msr = (UINT_PTR)__readmsr(IA32_SYSENTER_EIP);
    DbgPrint("Address of MSR entry %x is: %x.\r\n", IA32_SYSENTER_EIP, msr);
    return msr;
}

void WriteMSR(UINT_PTR msraddr)
{
    __writemsr(IA32_SYSENTER_EIP, msraddr);
    DbgPrint("Address of MSR entry %x is hooked: %x.\r\n", IA32_SYSENTER_EIP, msraddr);
}
#endif

void HookMSR(UINT32 hookaddr)
{
    UINT_PTR msraddr = 0;

    _disable();
    msraddr = ReadMSR();
    oldMSRAddress = msraddr;
    if (msraddr == hookaddr)
    {
        DbgPrint("The MSR IA32_SYSENTER_EIP is already hooked.\r\n");
    }
    else
    {
        DbgPrint("Hooking MSR IA32_SYSENTER_EIP: %x –> %x.\r\n", msraddr, hookaddr);
        WriteMSR(hookaddr);
    }
    _enable();
}

/*
 * Function that can be called directly from assembly inside HookRoutine.
 */
void DebugPrint(UINT32 d)
{
    if (d == 0x7)
    {
        DbgPrint("[*] Inside Hook Routine - dispatch %x called\r\n", d);
    }
}

__declspec(naked) int MsrHookRoutine()
{
    __asm {
        pushad
        pushfd

        mov ecx, 0x23
        push 0x30
        pop fs
        mov ds, cx
        mov es, cx

        push eax
        call DebugPrint

        popfd
        popad

        jmp oldMSRAddress
    }
}

NTSTATUS DriverDeviceControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    IO_STACK_LOCATION* io_stack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;
    
    switch (io_stack->Parameters.DeviceIoControl.IoControlCode)
    {
        case IOCTL_MYDRIVER_HOOK_MSR:
            HookMSR(0x176, (UINT32)MsrHookRoutine);
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    return status;
}

void DriverUnload(PDRIVER_OBJECT pDriverObject)
{
    UNREFERENCED_PARAMETER(pDriverObject);

    UNICODE_STRING deviceName;
    UNICODE_STRING symbolicLink;

    /* restore the msr hook */
    if (oldMSRAddress != NULL) {
        HookMSR(0x176, (UINT32)oldMSRAddress);
    }

    RtlInitUnicodeString(&deviceName, L"\\Device\\MyDriver");
    RtlInitUnicodeString(&symbolicLink, L"\\DosDevices\\MyDriver");
    IoDeleteDevice(ptrDeviceObject);
    IoDeleteSymbolicLink(&symbolicLink);
    DbgPrint("Driver unloading\n");
}

extern "C" NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
    UNREFERENCED_PARAMETER(RegistryPath);

    UNICODE_STRING deviceName;
    UNICODE_STRING symbolicLink;
    RtlInitUnicodeString(&deviceName, L"\\Device\\MyDriver");
    RtlInitUnicodeString(&symbolicLink, L"\\DosDevices\\MyDriver");
    IoCreateDevice(DriverObject, 0, &deviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, &ptrDeviceObject);
    IoCreateSymbolicLink(&symbolicLink, &deviceName);

    DriverObject->MajorFunction[IRP_MJ_CREATE] = DriverPassthrough;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = DriverPassthrough;
    DriverObject->MajorFunction[IRP_MJ_READ] = DriverPassthrough;
    DriverObject->MajorFunction[IRP_MJ_WRITE] = DriverPassthrough;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DriverDeviceControl;

    DriverObject->DriverUnload = DriverUnload;

    DbgPrint("MSR Hooking Demo Loaded!\r\n");
    return STATUS_SUCCESS;
}