from os import path, getcwd
from  base64 import b64decode
import json
import string
import idaapi


def rc4_crypt(key, data):
    """Return the decrypted string."""
    S = list(range(256))
    j = 0

    for i in list(range(256)):
        j = (j + S[i] + ord(key[i % len(key)])) % 256
        S[i], S[j] = S[j], S[i]

    j = 0
    y = 0
    out = []

    for byte in data:
        j = (j + 1) % 256
        y = (y + S[j]) % 256
        S[j], S[y] = S[y], S[j]
        out.append(chr(byte ^ S[(S[j] + S[y]) % 256]))
    return ''.join(out)


def get_start_addr(ea):
    """Return the address of the function (the start address of the function)."""
    return list(FuncItems(ea))[0]


def get_call_list(ea):
    """Find the functions that called from the given function and return list of functions addresses."""
    dism_addr_list = list(FuncItems(ea))
    return [get_operand_value(addr, 0) for addr in dism_addr_list if print_insn_mnem(addr) == 'call']


def sanitize_string(name, t='var'):
    """Return the sanitized string by its type."""
    if t == 'dll':
        return "".join([c for c in name if c in string.ascii_letters]).capitalize()
    elif t == 'var':
        return "".join([c for c in name if c in string.ascii_letters])[:20].capitalize()


def check_pattern(addr_list,pattern):
    """Check if the instruction patterns are matched"""
    if [print_insn_mnem(addr) for addr in addr_list] == pattern:
        return True
    return False


def scan_key(base_address):
    """Scan the strings setup function and find the decryption key and decryption func.

        Args:
        base_address -- the address for Oski stringsSetup function

        Returns:
            key -- decryption key
            decrypt_func_addr -- decryption function address
    """
    
    key = ''
    dism_addr_list = list(FuncItems(base_address))
    for addr in dism_addr_list:
        # check disassembly line
        if (print_insn_mnem(addr) != 'mov' and
        get_operand_type(addr, 0) != 2 and  # check for o_mem (Direct Memory Reference)
        get_operand_type(addr, 1) != 5):  # check for o_imm (Immediate Value)
            continue
        data_addr = get_operand_value(addr, 0)
        key_var_refs = []
        key_string_ref = get_operand_value(addr, 1)
        if len(list(XrefsTo(key_string_ref, 0))) != 0:  # has only 1 refs
            key_var_refs = list(XrefsTo(data_addr, 0))
            if len(key_var_refs) == 2:  # the second ref is for the usage of the ley within the decryption func
                key = idc.get_strlit_contents(key_string_ref).decode('utf-8')
                print("The decryption key is: %s" % key)

                if get_start_addr(key_var_refs[0].frm) == dism_addr_list[0]:  # validate ref address
                    decrypt_func_addr = get_start_addr(key_var_refs[1].frm)
                else:
                    decrypt_func_addr = get_start_addr(key_var_refs[0].frm)
                    set_name(decrypt_func_addr, 'decrypt_func', SN_NOWARN)
                print("The decryption func is: %s" % hex(decrypt_func_addr))

                return key, decrypt_func_addr


def strings_setup(base_address, key, decrypt_func_addr):
    """Find the pattern for string setup, set name and comment for the decrypted string and add
        it to dictionary.

        Args:
        base_address -- the address for Oski stringsSetup function
        key -- decryption key
        decrypt_func_addr -- decryption function address
    """

    """decryption pattern
    push    offset aGjnzinipsemrzq
    call    decrypt
    add     esp, 4
    mov     dword_14015C0, eax
    """
    pattern = ['push', 'call', 'add', 'mov']
    dism_addr_list = list(FuncItems(base_address))
    for i in range(0, len(dism_addr_list)-len(pattern)):
        if check_pattern(dism_addr_list[i:i + len(pattern)], pattern):
            if get_operand_value(dism_addr_list[i + 1], 0) == decrypt_func_addr:  # validate the call for decrypt func
                b64_addr = list(DataRefsFrom(dism_addr_list[i]))[0]
                b64_string = idc.get_strlit_contents(b64_addr).decode('utf-8')  # get the b64 string
                var_addr = list(DataRefsFrom(dism_addr_list[i + 3]))[0]
                decoded_b64 = b64decode(b64_string)
                decrypted = rc4_crypt(key, decoded_b64).replace('\x00', '?')

                strings_dic[var_addr] = decrypted
                set_cmt(var_addr, decrypted, 0)  # add comment with the full decrypted string
                name = sanitize_string(decrypted, 'var')
                set_name(var_addr, 'a%s' % name, SN_NOWARN)
    print("%s decrypted strings" % len(strings_dic))
    if len(strings_dic) <= 0:
        print('\n[+] Error on decryption the strings\n')
        exit(0)


def set_LoadLib_GetProc(proc_setup_func_addr):
    """Set LoadLibraryA and GetProcAddress within Oski's procsSetup function."""
    for addr, value in strings_dic.items():
        if 'LoadLibrary' in value or 'GetProcAddress' in value:
            for ref in XrefsTo(addr, 0):
                if get_start_addr(ref.frm) == proc_setup_func_addr:

                    last_addr = ref.frm
                    while (print_insn_mnem(last_addr) != 'call'):  # call to LoadLib/GetProc
                        last_addr = next_head(last_addr)
                    assign_addr = next_head(last_addr)
                    while (print_insn_mnem(assign_addr) != 'mov'):  # assign the return value to var (func name)
                        assign_addr = next_head(assign_addr)

                    if get_operand_type(assign_addr, 0) == 2:  # check for o_mem (Direct Memory Reference)
                        if get_operand_type(assign_addr, 1) == 1:  # check for o_reg (General Register)
                            func_addr = get_operand_value(assign_addr, 0)
                            set_name(func_addr, value, 0x800)  # SN_FORCE


def procs_setup(base_address):
    """Find the pattern for retrieving dynamically the address of functions by using GetProcAddress API,
        set the name for the retrieved functions, and add it to dictionary.

        Args:
        base_address -- the address for Oski procsSetup function
    """

    """GetProc pattern
    mov     ecx, aExitprocess
    push    ecx             ; lpProcName
    mov     edx, [ebp+pKernel32Base]
    push    edx             ; hModule
    call    GetProcAddress_0
    mov     dword_4317B4, eax
    """
    pattern = ['mov', 'push', 'mov', 'push', 'call', 'mov']
    dism_addr_list = list(FuncItems(base_address))
    for i in range(0, len(dism_addr_list)-len(pattern)):
        if check_pattern(dism_addr_list[i:i + len(pattern)], pattern):
            if "GetProcAddress" in print_operand(dism_addr_list[i + 4], 0):
                if get_operand_type(dism_addr_list[i + 1],
                                    0) == 0x5:  # when the function name isn't encrypted
                    proc_string_addr = list(DataRefsFrom(dism_addr_list[i + 1]))[0]
                    proc_name = idc.get_strlit_contents(proc_string_addr).decode('utf-8')
                else:
                    proc_string_addr = list(DataRefsFrom(dism_addr_list[i]))[0]
                    proc_name = strings_dic[proc_string_addr]

                var_addr = list(DataRefsFrom(dism_addr_list[i + 5]))[0]
                set_name(var_addr, proc_name, 0x800)  # SN_FORCE
                procs_dic[var_addr] = proc_name
    print("%s dynamic procs" % len(procs_dic))


def dlls_setup(base_address):
    """Find the pattern for loading dynamically DLLs by using LoadLibrary API,
        set the name for the retrieved dll.

        Args:
        base_address -- the address for Oski procsSetup function
    """

    """LoadLibrary pattern
    mov     eax, aBcryptdll
    push    eax             ; lpLibFileName
    call    LoadLibraryA
    mov     [ebp+hModule], eax
    """
    pattern = ['mov', 'push', 'call', 'mov']
    dism_addr_list = list(FuncItems(base_address))
    pFunc = idaapi.get_func(base_address)
    pFrame = ida_frame.get_frame(base_address)
    counter_dlls = 0
    for i in range(0, len(dism_addr_list)-len(pattern)):
        if check_pattern(dism_addr_list[i:i + len(pattern)], pattern):
            if "LoadLibrary" in print_operand(dism_addr_list[i + 2], 0):
                dll_string_addr = list(DataRefsFrom(dism_addr_list[i]))[0]
                dll_name = get_cmt(dll_string_addr,0)
                # rename stack variable
                inst = DecodeInstruction(dism_addr_list[i + 3])
                offset = (idaapi.calc_stkvar_struc_offset(pFunc, inst, 0))
                name = sanitize_string(dll_name, 'dll')
                ida_struct.set_member_name(pFrame, offset, 'h%s' % name)
                counter_dlls += 1
    print("%s dynamic dlls" % counter_dlls)


def oski_setup(WinMain_address):
    """Decrypt and rename the strings, resolve the functions and Dlls names/addresses,
        and dump the data to JSON file.

        Args:
        WinMain_address -- the address for Oski's Main function
    """

    print('[+] Oski Builder started')

    global strings_dic, procs_dic
    strings_dic = {}
    procs_dic = {}
    dump_file = path.join(getcwd(), 'oski_strings_dump.json')

    call_func_list = get_call_list(WinMain_address)  # get the function in main
    if len(call_func_list) <= 0:
        print('\n[+] Error on finding Oski main functions\n')
        exit(0)

    print('[+] Strings decryption')
    dec_key, decrypt_func = scan_key(call_func_list[0])  # first function: stringsSetup
    strings_setup(call_func_list[0], dec_key, decrypt_func)

    print('[+] Set LoadLibrary and GetProcAddress')
    set_LoadLib_GetProc(call_func_list[1])  # second function: procSetup

    print('[+] Functions and DLLs loading')
    dlls_setup(call_func_list[1])
    procs_setup(call_func_list[1])

    print('[+] Dump strings to %s' % dump_file)
    with open(dump_file, 'w') as f:
        json.dump([{'decryption_key': dec_key}, {'decrypted strings': strings_dic}, {'loaded functions': procs_dic}],
                  f,indent=4, ensure_ascii=True)

    print('[+] Oski Builder finished')


if __name__ == "__main__":
    oski_setup(here())