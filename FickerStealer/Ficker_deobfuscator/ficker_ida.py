from os import path, getcwd
import json
import string


def get_dynamic_call_address(ea):
    """Find all dynamic calls e.g call eax"""
    dism_addr_list = list(FuncItems(ea))
    return [addr for addr in dism_addr_list if print_insn_mnem(addr) == 'call' and get_operand_type(addr, 0)==1]


def find_decryption_func_addr(ea, string_dec_func_name):
    """
    Find the malware's decryption algorithm and set the function name.
    Return the decryption function's address.
    """
    decrypt_pattern_addr = find_binary(ea, SEARCH_DOWN | SEARCH_REGEX, "89 ? C1 ? ? 31 ? 89 ? C1 ? ? 31 ? 8B ? ? 89 ? C1 ? ? 31")
    str_decrypt_func_addr = ida_funcs.get_func(decrypt_pattern_addr).start_ea
    set_name(str_decrypt_func_addr, string_dec_func_name)
    return str_decrypt_func_addr


def str_decrypt(key,enc):
    """malware string decryption algorithm"""
    dec =""
    for i in enc:
        tmp1 = ((key << 13) ^ key) & 0xffffffff
        tmp2 = (tmp1 >> 17) ^ tmp1 & 0xffffffff
        key = (tmp2 << 5) ^ tmp2 & 0xffffffff
        dec += chr(i + key & 0xff)
    return dec


def get_obf_string(obf_addr, str_len): #string_decrpyt function
    """
    Calculates the "real" enc_struc 
    Return the decrypted the string
    """
    string_dec_const = 0x25
    enc_struc = obf_addr + string_dec_const * str_len - 4
    key = int.from_bytes(ida_bytes.get_bytes(enc_struc,4) , 'little')
    enc_str = ida_bytes.get_bytes(enc_struc + 4, str_len)
    return str_decrypt(key, enc_str)


def get_ref(ea, op_index):
    """
    Find references to the desired operand by checking the previous instructions
    Return the address if it's found
    """
    reg = print_operand(ea, op_index)
    ea = prev_head(ea)
    curent_func_addr = ida_funcs.get_func(ea).start_ea
    
    if reg == 'eax':
        while print_insn_mnem(ea) != 'call' and ea != curent_func_addr: # eax changed by the return value of the called function
            if print_operand(ea,0) == reg: # get assigner
                return ea
            ea = prev_head(ea)
        return -1
    else:
        while print_operand(ea,0) != reg: # get assigner
            if ea == curent_func_addr:
                return -1
            ea = prev_head(ea)
        return ea


def get_value_from(ea):
    """
    Recrusive function- gets an instruction address
    Return the value for the instruction
    """
    if ea == -1:
        return -1
               
    if print_insn_mnem(ea) == 'add':
        first_ref = get_ref(ea, 0)
        sec_ref = get_ref(ea, 1)
        return (get_value_from(first_ref) + get_value_from(sec_ref)) & 0xffffffff

    # check the seconed operand
    if print_insn_mnem(ea) == 'lea' or print_insn_mnem(ea) == 'mov':
        second_op_type = get_operand_type(ea,1)
        if (second_op_type == 2 or second_op_type == 5): # mem_addr / imm_value
            return  get_operand_value(ea,1) & 0xffffffff # the second opreand is data
        else: # the opreand is also reg -> find the next ref
            sec_ref = get_ref(ea, 1)
            return get_value_from(sec_ref)
    
    # check the first operand
    if print_insn_mnem(ea) == 'call' or print_insn_mnem(ea) == 'push':
        second_op_type = get_operand_type(ea,0)
        if (second_op_type == 2 or second_op_type == 5): # mem_addr / imm_value
            return  get_operand_value(ea,0) & 0xffffffff # the second opreand is data
        else: # the opreand is also reg -> find the next ref
            first_ref = get_ref(ea, 0)
            return get_value_from(first_ref)

    # push-pop obfuscation
    if print_insn_mnem(ea) == 'pop':
        pop_counter = 1
        while pop_counter != 0: # check matach between pop-push
            ea = prev_head(ea)
            while(print_insn_mnem(ea) != 'push'): #sequence of pops
                if print_insn_mnem(ea)  == 'pop':
                    pop_counter += 1 
                ea = prev_head(ea)
            pop_counter -= 1 # found push
        return get_value_from(ea)
    

def get_func_parmas(call_addr, num_parms):
    """ Return list of addresses for the func parameters (by stack)"""
    push_counter = 0
    parms_list = []
    ea = prev_head(call_addr)
    while (push_counter != num_parms):
        if print_insn_mnem(ea) == 'push':
            parms_list.append(ea)
            push_counter += 1
        elif print_insn_mnem(ea) == 'pop':
            while(print_insn_mnem(ea) != 'push'):
                ea = prev_head(ea)
        ea = prev_head(ea) # skip push instr
    return parms_list


def ficker_main(ea):
    """Deobfuscate Ficker's strings, and dump the data to JSON file.

        Args:
        WinMain_address -- Ficker's Main address function
    """

    print('[+] Ficker deobfuscator started')

    strings_dic = {}
    stack_var = []
    dynamic_call_list = []
    dump_file = path.join(getcwd(), 'ficker_strings_dump.json')

    string_dec_func_name = 'string_decrypt'
    string_dec_addr = find_decryption_func_addr(ea, string_dec_func_name)
    
    for func_ea in Functions():
        dynamic_call_list += get_dynamic_call_address(func_ea)
    if len(dynamic_call_list) <= 0:
        print('\n[+] There is no dynamic calls\n')
        exit(0)

    print('[+] Strings decryption')
    for call_addr in dynamic_call_list:
        if string_dec_addr == get_value_from(call_addr): # check if dynamic call addr is string_decryption function            
            set_cmt(call_addr, string_dec_func_name, 0)
            add_cref(call_addr, string_dec_addr, 1)
            push_pDest, push_str_len, push_obf_enc_struc = get_func_parmas(call_addr, 3) # get the arguments for string_decryption function
            
            if 'esp' in print_operand(push_str_len,0) or 'esp' in print_operand(push_obf_enc_struc,0):
                stack_var.append(call_addr)
            else:
                dec_str = get_obf_string(get_value_from(push_obf_enc_struc), get_value_from(push_str_len))
                print("%x: %s" % (call_addr, dec_str))
                strings_dic[hex(call_addr)] = dec_str
                set_cmt(push_pDest, dec_str, 0)

    print("[+] %s decrypted strings" % len(strings_dic))

    print('[+] Dump strings to %s' % dump_file)
    with open(dump_file, 'w') as f:
        json.dump([{'decrypted strings': strings_dic}, {'unknown parameters': [hex(x) for x in stack_var]}],
                  f,indent=4, ensure_ascii=True)

    print('[+] Ficker deobfuscator finished\n')


if __name__ == "__main__":
    ficker_main(here())